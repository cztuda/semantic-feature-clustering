#pragma once

namespace manutec {
//[...]


template<class Type, class Array, class constArray>
void r3m2si(Array aqdd, const Type ml, constArray aq, constArray aqd, constArray fgen){
//
// Simulation model equations of the Manutec r3 robot (DFVLR model 2)
//
// Procedure purpose:
//   This subroutine calculates the generalized accelerations (AQDD) for
//   the Manutec r3 robot of the DFVLR model 2. This model is based on
//   the following assumptions:
//
//   - The last 3 joints (joints 4,5,6) of the robot hand do not move.
//     This corresponds to the case that the brakes in these joints are
//     blocked (joints 4,5,6 are taken into account in model 1).
//
//   - The robot consists of a base body (the environment), three arms
//     and three rotors. The rotors represent the inertia effects of the
//     motors and of the wheels of the gear boxes. The rotors are
//     embedded in the preceeding arms, e.g. the rotor 2, which drives
//     arm2, is embedded in arm1.
//
//   - Arms and rotors are considered to be rigid bodies.
//
//   - Elasticity, backlash and friction in the gear boxes are neglected.
//
//   - The motors are modelled as ideal voltage-torque converters
//     without any dynamic effects. As input arguments of the subroutine
//     the torques at the gear output (FGEN in <Nm>) must be given. If the
//     voltage (U in <V>) at the input of the current regulator of the
//     motor is given, FGEN must be calculated (before calling this
//     subroutine) in the following way:
//         FGEN(1) = -126.0*U(1)
//         FGEN(2) =  252.0*U(2)
//         FGEN(3) =   72.0*U(3)
//
//   - At the robot's tip a load mass (ML) is attached. It can range
//     between 0 ... 15 kg.
//
//   Given the actual value ML of the load mass, the joint angles AQ(i),
//   the derivatives of the joint angles AQD(i), and the driving torques
//   in the joints FGEN(i), the second derivatives of the joint angles
//   AQDD(i) are calculated by this subroutine.
//
// Usage:
//   CALL  R3M2SI (ML, AQ, AQD, FGEN, AQDD)
//
//   ML    :  IN, ARRAY, <kg>, 0<=ML<=15
//            Load mass.
//   AQ    :  IN, ARRAY(3), <rad>, -2.97 <= AQ(1) <= 2.97  (+/- 170 deg),
//                                  -2.01 <= AQ(2) <= 2.01  (+/- 115 deg),
//                                  -2.86 <= AQ(3) <= 2.86  (+/- 164 deg)
//            (The given limits are hardware constraints by limit switches).
//            Vector of generalized coordinates (relative angles between
//            two contigous robot arms).
//            AQ(1) is not used in this subroutine, because it is not
//            needed to calculate AQDD.
//   AQD   :  IN, ARRAY(3), <rad/sec>,
//                                -3.0 <= AQD(1) <= 3.0  (+/- 172 deg/sec),
//                                -1.5 <= AQD(2) <= 1.5  (+/-  86 deg/sec),
//                                -5.2 <= AQD(3) <= 5.2  (+/- 298 deg/sec)
//            Derivative of AQ.
//   FGEN  :  IN, ARRAY(3), <Nm>,     -945.0 <= FGEN(1) <=  945.0,
//                                    -1890.0 <= FGEN(2) <= 1890.0,
//                                     -540.0 <= FGEN(3) <=  540.0
//            Torque at the gear output.
//   AQDD  :  OUT, ARRAY(3), <rad/sec**2>
//            Second derivative of AQ.
//
// Bibliography:
//   A detailed description of the model, together with the body-data
//   (mass, center of mass etc. of the arms and rotors) is given in
//     Otter M., Tuerk S., Mathematical Model of the Manutec r3 Robot,
//            (DFVLR Model No. 2), DFVLR - Oberpfaffenhofen, Institut fuer
//            Dynamik der Flugsysteme, D-8031 Wessling, West Germany,
//            corrected version april 1988.
//
//   This subroutine was generated by the program MYROBOT. See
//     Otter M., Schlegel S., Symbolic generation of efficient simulation
//            codes for robots. 2nd European Simulation Multiconference,
//            June 1-3, 1988, Nice.
//
//   The underlying multibody algorithm is a modified version of
//     Brandl H., Johanni R., Otter M., A very efficient algorithm for the
//            simulation of robots and similar multibody systems without
//            inversion of the mass matrix. IFAC/IFIP/IMACS International
//            Symposium on Theory of Robots, december 3-5, 1986, Vienna.
//
// Remarks:
//   - The limits given for the input variables are not checked in
//     this subroutine. The user is responsible for proper data.
//
//
// Copyright:
//   1988  DFVLR - Institut fuer Dynamik der Flugsysteme
//
// Life cycle:
//   1988 APR  M. Otter, S. Tuerk (DFVLR)             : specified.
//   1988 APR  M. Otter (DFVLR)                       : generated.
//   1988 APR  M. Otter, C. Schlegel, S. Tuerk (DFVLR): tested.
//-----------------------------------------------------------------------

    
//[...]
}


template<class Type, class Array, class constArray>
void dynamics(Array f, constArray x, constArray u, constArray p, constArray c){
//**********************************************************************
// Purpose:
// -------
//    Computation of the right hand side F of the differential equations
//
//                  DX/DT  =  F(X, U, P)
//
//    in phase number IPHASE.
//
// ENTRY-Parameters:
// ----------------
//    X........the state variables at time T (array of length 6)
//    U........the control variables at time T (array of length 3)
//    P........the control parameters (array of length 1)
//
// EXIT-Parameters:
// ----------------
//    F........computed value of the right hand side of the
//             differential equations in phase IPHASE at time T
//             (array of length 6)
//**********************************************************************
//

//[...]
}
}

template<class Type, class Array, class constArray>
void dynamics(Array f, constArray state, constArray control, constArray constants, constArray parameter, const unsigned int nx, const unsigned int nu, const unsigned int nc, const unsigned int np, const unsigned int mode)
{
    manutec::dynamics<Type, Array, constArray>(f, state, control, parameter, constants);
}
